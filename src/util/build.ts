import {message, save} from '@tauri-apps/plugin-dialog'
import {MapData, parseMapData} from '../pages/map/types'
import {sendReadFile, sendSaveFile} from './api'
import { ActorData, parseActorData, UVFunc, UVFuncPoint } from '../pages/actor/types'

export type Project = {
  actors: string[]
  maps: string[]
}
export function parseProject(s: string): Project | null {
  let o: any = null
  try {
    o = JSON.parse(s)
  } catch (e) {
    return null
  }
  const check =
    typeof o === 'object' &&
    o !== null &&
    Array.isArray(o.actors) &&
    o.actors.every((n: any) => typeof n === 'string') &&
    Array.isArray(o.maps) &&
    o.maps.every((n: any) => typeof n === 'string')
  return check ? o : null
}

function float(num: number): string {
  return Number.isInteger(num) ? `${num}.0` : String(num)
}

function buildActor(name: string, data: ActorData): string {
  function buildUVFuncPoint(points: UVFuncPoint[]): string {
    let s = ""
    for (const p of points.reverse()) {
      s += `                if time >= ${float(p.time)} { return Vec4::new(${float(p.l)}, ${float(p.t)}, ${float(p.w)}, ${float(p.h)}); }\n`
    }
    s += `                return Vec4::new(0.0, 0.0, 1.0, 1.0);`
    return s
  }
  function buildUVFunc(fname: string, func: UVFunc): string {
    return `\
    fn ${fname}(direction: ActorDirection, time: f32) -> Vec4 {
        match direction {
            ActorDirection::Left => {
${buildUVFuncPoint(func.left)}
            }
            ActorDirection::Right => {
${buildUVFuncPoint(func.right)}
            }
            ActorDirection::Up => {
${buildUVFuncPoint(func.up)}
            }
            ActorDirection::Down => {
${buildUVFuncPoint(func.down)}
            }
        }
    }`
  }

  return `
pub mod ${name} {
    use super::*;
${buildUVFunc('idle_uv', data.idle)}
${buildUVFunc('moving_uv', data.moving)}
    pub fn init(mngrs: &mut Managers, i: usize, j: usize) -> Actor {
        let _ = mngrs.gr_mngr.load_image(&mut mngrs.rs_mngr, "${data.image}");
        Actor::new(i, j, ${float(data.width)}, ${float(data.height)}, 240.0, "${data.image}", idle_uv, moving_uv)
    }
}
`
}

function buildMap(name: string, data: MapData): string {
  const image = data.image

  let tiles = '        let mut tiles = Vec::new();\n'
  for (let i = 0; i < data.tiles.length; ++i) {
    tiles += '        let mut row = Vec::new();\n'
    for (let j = 0; j < data.tiles[i].length; ++j) {
      const tile = data.tiles[i][j]
      const passable = true
      tiles += `        row.push(MapTile::new(${i}, ${j}, "${image}", Vec4::new(${float(tile.uv.left)}, ${float(tile.uv.top)}, ${float(tile.uv.right)}, ${float(tile.uv.bottom)}), ${passable}));\n`
    }
    tiles += '        tiles.push(row);\n'
  }
  tiles += '        let tiles = MapTiles { tiles };'

  return `
pub mod ${name} {
    use super::*;
    pub fn init(mngrs: &mut Managers) -> MapScene {
        let _ = mngrs.gr_mngr.load_image(&mut mngrs.rs_mngr, "${image}");
${tiles}
        let mut actors = HashMap::new();
        let mut events = Vec::<Event>::new();
        MapScene::new(tiles, actors, events)
    }
}
`
}

export async function build(rootPath: string, project: Project) {
  const destination = await save()
  if (!destination) {
    message('出力に失敗しました。')
    return
  }

  let code = `\
//! This file was automatically generated by rpg-editor.
//! This module must belong to crate::client::generated.
//! Do not commit this file to Git in rpg-infrastructure.

#![allow(unused_mut)]
#![allow(unused_imports)]

use crate::{client::{component::*, scene::map::MapScene}, engine::Managers};
use glam::*;
use std::collections::HashMap;
use winit::keyboard::KeyCode;
`
  for (const name of project.actors) {
    const path = `${rootPath}/${name}`
    const response = await sendReadFile(path)
    if (!response.ok) {
      message(response.content)
      return
    }
    const data = parseActorData(response.content)
    if (!data) {
      message(`${path}は無効なデータです。`)
      return
    }
    code += buildActor(name, data)
  }
  for (const name of project.maps) {
    const path = `${rootPath}/${name}`
    const response = await sendReadFile(path)
    if (!response.ok) {
      message(response.content)
      return
    }
    const data = parseMapData(response.content)
    if (!data) {
      message(`${path}は無効なデータです。`)
      return
    }
    code += buildMap(name, data)
  }

  if (await sendSaveFile(destination, code)) {
    message('出力に成功しました。')
  } else {
    message('出力に失敗しました。')
  }
}

//! This file was automatically generated by rpg-editor.
//! This module must belong to crate::client::generated.
//! Do not commit this file to Git in rpg-infrastructure.

#![allow(unused_mut)]
#![allow(unused_imports)]

use crate::{client::{component::*, scene::map::MapScene}, engine::Managers};
use glam::*;
use std::collections::HashMap;
use std::time::Duration;
use winit::keyboard::KeyCode;

pub mod actor1 {
    use super::*;
    fn idle_uv(direction: ActorDirection, time: f32) -> Vec4 {
        match direction {
            ActorDirection::Left => {
                if time >= 0.0 { return Vec4::new(0.0, 0.0, 0.1875, 0.25); }
                return Vec4::new(0.0, 0.0, 1.0, 1.0);
            }
            ActorDirection::Right => {
                if time >= 0.0 { return Vec4::new(0.0, 0.25, 0.1875, 0.25); }
                return Vec4::new(0.0, 0.0, 1.0, 1.0);
            }
            ActorDirection::Up => {
                if time >= 0.0 { return Vec4::new(0.0, 0.5, 0.1875, 0.25); }
                return Vec4::new(0.0, 0.0, 1.0, 1.0);
            }
            ActorDirection::Down => {
                if time >= 0.0 { return Vec4::new(0.0, 0.75, 0.1875, 0.25); }
                return Vec4::new(0.0, 0.0, 1.0, 1.0);
            }
        }
    }
    fn moving_uv(direction: ActorDirection, time: f32) -> Vec4 {
        match direction {
            ActorDirection::Left => {
                if time >= 0.666 { return Vec4::new(0.375, 0.0, 0.1875, 0.25); }
                if time >= 0.333 { return Vec4::new(0.1875, 0.0, 0.1875, 0.25); }
                if time >= 0.0 { return Vec4::new(0.0, 0.0, 0.1875, 0.25); }
                return Vec4::new(0.0, 0.0, 1.0, 1.0);
            }
            ActorDirection::Right => {
                if time >= 0.666 { return Vec4::new(0.375, 0.25, 0.1875, 0.25); }
                if time >= 0.333 { return Vec4::new(0.1875, 0.25, 0.1875, 0.25); }
                if time >= 0.0 { return Vec4::new(0.0, 0.25, 0.1875, 0.25); }
                return Vec4::new(0.0, 0.0, 1.0, 1.0);
            }
            ActorDirection::Up => {
                if time >= 0.666 { return Vec4::new(0.375, 0.5, 0.1875, 0.25); }
                if time >= 0.333 { return Vec4::new(0.1875, 0.5, 0.1875, 0.25); }
                if time >= 0.0 { return Vec4::new(0.0, 0.5, 0.1875, 0.25); }
                return Vec4::new(0.0, 0.0, 1.0, 1.0);
            }
            ActorDirection::Down => {
                if time >= 0.666 { return Vec4::new(0.375, 0.75, 0.1875, 0.25); }
                if time >= 0.333 { return Vec4::new(0.1875, 0.75, 0.1875, 0.25); }
                if time >= 0.0 { return Vec4::new(0.0, 0.75, 0.1875, 0.25); }
                return Vec4::new(0.0, 0.0, 1.0, 1.0);
            }
        }
    }
    fn control(this: &mut Actor, mngrs: &mut Managers, coms: &mut Components, duration: Duration) -> bool {
// プレイヤーが移動不可であれば早期リターン
if coms.message_box.is_some() {
    return true;
}

// プレイヤーが移動開始不可であれば移動して早期リターン
if !this.can_start_move() {
    this.do_move(duration);
    coms.camera.chase(this.get_position());
    return true;
}

// 新しく入力された方向を取得
const DIRECTIONS: [(KeyCode, (i32, i32, ActorDirection)); 4] = [
    (KeyCode::ArrowLeft, (0, -1, ActorDirection::Left)),
    (KeyCode::ArrowRight, (0, 1, ActorDirection::Right)),
    (KeyCode::ArrowUp, (-1, 0, ActorDirection::Up)),
    (KeyCode::ArrowDown, (1, 0, ActorDirection::Down)),
];
let mut recent_input = None;
let mut min_state = std::u32::MAX;
for (kc, n) in &DIRECTIONS {
    let state = mngrs.in_mngr.get(kc);
    if state > 0 && state < min_state {
        recent_input = Some(n.clone());
        min_state = state;
    }
}

// 新しく入力された方向がないなら移動して早期リターン
let Some((di, dj, direction)) = recent_input else {
    this.do_move(duration);
    coms.camera.chase(this.get_position());
    return true;
};

// 取り敢えず向きを変更
this.change_direction(direction.clone());

// 旧座標から新座標取得
let (oi, oj) = this.get_ij();
let (ni, nj) = (oi as i32 + di, oj as i32 + dj);

// 移動先が進入可能ならば移動開始
// TODO: アクター同士がぶつからないようにする。
if ni >= 0 && nj >= 0 {
    if let Some(tile) = coms.tiles.get(ni as usize, nj as usize) {
        if tile.is_passable() {
            this.start_move(direction);
        }
    }
}

// 移動
this.do_move(duration);
coms.camera.chase(this.get_position());

return true;

    }

    pub fn init(mngrs: &mut Managers, i: usize, j: usize) -> Actor {
        let _ = mngrs.gr_mngr.load_image(&mut mngrs.rs_mngr, "actor1.png");
        let mut events = Vec::<ActorEvent>::new();
        events.push(control);

        Actor::new(i, j, 48.0, 64.0, 240.0, "actor1.png", idle_uv, moving_uv, events)
    }
}

pub mod first {
    use super::*;
    pub fn init(mngrs: &mut Managers) -> MapScene {
        let _ = mngrs.gr_mngr.load_image(&mut mngrs.rs_mngr, "tiles.png");
        let mut tiles = Vec::new();
        let mut row = Vec::new();
        row.push(MapTile::new(0, 0, "tiles.png", Vec4::new(0.0, 0.0, 0.375, 0.375), true));
        tiles.push(row);
        let tiles = MapTiles { tiles };
        let mut actors = HashMap::new();
        let mut events = Vec::<Event>::new();
        MapScene::new(tiles, actors, events)
    }
}
